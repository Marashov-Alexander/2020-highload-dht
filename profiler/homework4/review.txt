PUT and GET locks:
По диаграмме видно, что все блокировки делятся между селекторами (постановка задач в ExecutorService) и воркерами (получение этих задач). При этом во время PUT запросов доля блокировок со стороны селекторов значительно меньше. Более того, во время put запросов блокировок в целом на порядок меньше.

PUT alloc:
Разделение по воркерам и селекторам сохраняется. На одного воркера, как и на одного селектора, уходит в среднем по 6 процентов потребляемой памяти.
При этом потребление селекторами кардинально ничем не отличается от результатов прошлого этапа, поэтому обратимся к разбору потребления памяти отдельным воркером. Оказалось, что из 6% на работу метода primaryFor (поиск ноды для заданного ключа) уходит около 3% (почти половина). В частности, почти 2% потребляется методом findFirst. Реализация через стримы получилась неэффективной по памяти. Факт, что на работу самого ДАО ушло чуть более одного процента, подчёркивает этот вывод.

GET ALLOC:
в целом картина та же, что и в PUT alloc, но на работу ДАО в одном воркере уходит памяти в три раза больше (3%). На поиск ноды для ключа тоже уходит значительное количество ресурсов: 1,5%.

PUT and GET cpu:
Что касается процессорного времени, то при PUT запросах каждый селектор занимает порядка 4%, а каждый воркер - около 8%. В воркере приблизительно 3% уходит на получение задачи, а остальное - на Dao.Upsert (0.5%), поиск ноды для ключа (0.3%) и создание / отправку ответа (оставшееся).
При GET запросах разделение между селекторами / воркерами сохраняется, но на работу ДАО уходит в два раза больше (1%), на поиск ноды - 0.2%, на отправку ответа - 4%, на выборку задач воркером - 2.5%.