CPU put test:
По графику видно, что два основных направления, на которые тратится больше всего процессорного времени - это отправка ответа клиенту (37.01%) и работа логики самого приложения (48.03%).
Мы не можем напрямую влиять на этапы формирования ответа и его отправки, поэтому обратимся ко второму направлению. Приблизив график, я увидел, что 14 процентов процессорного времени потреблял метод String.format, который я вызываю при логировании. К логированию же относится и Arrays.toString (2.36%). Мало того, сам Log4JLogger.debug занимает аж 27.56%! И только лишь 2.36% уходит на DAOImpl.upsert (вставка значения), 1.57% - на оборачивание массива байт в ByteBuffer.
Первичный вывод очевиден: для оптимизации системы необходимо ограничить уровень подробности логов значением "info". А факт, что реализация DAO (upsert метод) потребляет столько же процессорного времени, сколько метод Arrays.toString для логирования, говорит о достаточно хорошем потенциале к дальнейшей оптимизации системы.

alloc put test:
Что касается измерения памяти: общая картина стала ещё радикальнее. Наибольшее количество ресурсов по-прежнему отводится под логирование (String.format - 41.6%, Arrays.toStriing - 9.45%, Log4JLogger.debug - 23.78%). Всего лишь 3 процента потребляемой памяти уходит на отправку ответа, а на вставку значения в DAO - 1.07%, что очень впечатляет. 

cpu get test:
Перейдём к рассмотрению результатов профилирования get-запросов. На отправку ответов отводится менее 1 процента (0.51%) процессорного времени, 0.1% - на логирование, зато на работу DAO - 99.04%.

alloc get test:
Наибольшее потребление памяти при "обстреле" get-запросами также принадлежит логике самого приложения (83.64%). Из них огромную часть снова потребляет логирование (24.69% - Log4JLogger.debug, 11.73% - ByteBuffer.toString, 29.63% - String.format), а DAO отоводится 17.28 процентов потребляемой памяти, из которых практически всё - итераторы по хранилищу.
